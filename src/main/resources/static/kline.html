<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>BTC/USDT K線圖</title>
    <style>
        #chart {
            width: 100%;
            height: 500px;
        }
    </style>
    <!-- 引入 TradingView Lightweight Charts 庫 -->
    <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
<h1>BTC/USDT K線圖</h1>
<div id="chart"></div>

<script>
    // 創建圖表
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
        width: document.body.clientWidth,
        height: 500,
        layout: {
            backgroundColor: '#FFFFFF',
            textColor: '#000',
        },
        grid: {
            vertLines: {
                color: '#e1e1e1',
            },
            horzLines: {
                color: '#e1e1e1',
            },
        },
        crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
        },
        rightPriceScale: {
            borderColor: '#AAA',
        },
        timeScale: {
            borderColor: '#AAA',
            timeVisible: true,
            secondsVisible: false,
        },
    });

    const candleSeries = chart.addCandlestickSeries();
    let visibleCandles = 50; // 初始顯示50根K線
    const minCandles = 10;   // 最少顯示10根
    const maxCandles = 10000;  // 最多顯示300根
    let originalData = []; // 用來儲存K線數據
    let lastCandle = null; // 用來儲存當前的未結束K棒（例如50分的K棒）

    // 設置 WebSocket 連接
    const socket = new WebSocket('ws://localhost:8081/ws/kline'); // 替換為你的WebSocket地址

    // 監聽WebSocket消息
    socket.onmessage = function(event) {
        const message = JSON.parse(event.data);
        console.log("Got message: ", message);

        // 處理歷史K線數據 (假設歷史K線以數組形式傳送)
        if (Array.isArray(message) && message.length > 0 && message[0].type === 'historical') {
            originalData = message.map(d => ({
                time: d.time, // 假設傳來的是秒級時間戳
                open: d.open,
                high: d.high,
                low: d.low,
                close: d.close
            })).sort((a, b) => a.time - b.time);

            console.log("歷史數據：", originalData);
            candleSeries.setData(originalData); // 初始化時直接設定K線數據
        }

        // 處理查詢當下的那根K棒的既有數據
        else if (message.type === 'current_kline' && message.symbol === 'BTCUSDT') {
            const currentMinute = Math.floor(message.time / 60); // 將秒級時間戳轉換為分鐘級

            // 如果沒有當前未結束的K棒，或者時間不同，創建一根新的K棒
            if (!lastCandle || Math.floor(lastCandle.time / 60) !== currentMinute) {
                if (lastCandle) {
                    // 如果有上一根K棒，則認為它已經完成，加入到數據中
                    originalData.push(lastCandle);
                    updateChart(); // 確保圖表更新
                }

                // 創建新K棒，將上一根K棒的收盤價作為新K棒的開盤價
                lastCandle = {
                    time: message.time, // 設定當前時間
                    open: lastCandle ? lastCandle.close : message.open, // 使用上一根K棒的收盤價
                    high: message.high,
                    low: message.low,
                    close: message.close
                };
            } else {
                // 如果已有當前未結束的K棒，更新其數據
                lastCandle.high = Math.max(lastCandle.high, message.high);
                lastCandle.low = Math.min(lastCandle.low, message.low);
                lastCandle.close = message.close;
            }

            // 更新圖表
            candleSeries.update(lastCandle);
        }

        // 處理實時成交數據，更新當前K棒的收盤價和最高/最低價
        else if (message.type === 'trade' && message.symbol === 'BTCUSDT') {
            const tradeMinute = Math.floor(message.time / 60); // 將trade時間轉換為分鐘級

            // 檢查 trade 是否屬於當前K線
            if (lastCandle && Math.floor(lastCandle.time / 60) === tradeMinute) {
                // 更新當前K棒的收盤價、最高價和最低價
                lastCandle.close = message.price;
                lastCandle.high = Math.max(lastCandle.high, message.price);
                lastCandle.low = Math.min(lastCandle.low, message.price);

                // 更新圖表
                candleSeries.update(lastCandle);
            } else if (lastCandle) {
                // 如果 trade 已經進入下一分鐘，將當前K棒收盤並開始新K棒
                originalData.push(lastCandle); // 將舊K棒存入數據
                updateChart(); // 更新圖表以反映舊K棒的結束

                // 創建新K棒，開盤價為上一根K棒的收盤價
                lastCandle = {
                    time: message.time,
                    open: lastCandle.close, // 使用上一根K棒的收盤價作為新K棒的開盤價
                    high: message.price,
                    low: message.price,
                    close: message.price
                };

                // 更新新K棒到圖表
                candleSeries.update(lastCandle);
            }
        }
    };


    // 錯誤處理
    socket.onerror = function(error) {
        console.error('WebSocket 出現錯誤: ', error);
    };

    // WebSocket關閉處理
    socket.onclose = function() {
        console.log('WebSocket 連接已關閉');
    };

    // 更新圖表數據
    function updateChart() {
        const dataToShow = originalData.slice(-visibleCandles);
        candleSeries.setData(dataToShow);
        // 調整時間範圍以適應數據
        chart.timeScale().fitContent();
    }

    // 監聽滑鼠滾輪事件以縮放K線數量
    document.getElementById('chart').addEventListener('wheel', function(event) {
        event.preventDefault(); // 防止頁面滾動

        if (event.deltaY < 0) {
            // 滾輪向上 (放大)
            visibleCandles = Math.max(visibleCandles - 10, minCandles);
        } else {
            // 滾輪向下 (縮小)
            visibleCandles = Math.min(visibleCandles + 10, maxCandles);
        }
        updateChart();
    });
</script>
</body>
</html>
