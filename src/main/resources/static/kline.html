<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>BTC/USDT K線圖</title>
    <style>
        #chart {
            width: 100%;
            height: 500px;
        }
    </style>
    <!-- 引入 TradingView Lightweight Charts 庫 -->
    <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
<h1>BTC/USDT K線圖</h1>
<div id="chart"></div>

<script>
    // 創建圖表
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
        width: document.body.clientWidth,
        height: 500,
        layout: {
            backgroundColor: '#FFFFFF',
            textColor: '#000',
        },
        grid: {
            vertLines: {
                color: '#e1e1e1',
            },
            horzLines: {
                color: '#e1e1e1',
            },
        },
        crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
        },
        rightPriceScale: {
            borderColor: '#AAA',
        },
        timeScale: {
            borderColor: '#AAA',
            timeVisible: true,
            secondsVisible: false,
        },
    });

    const candleSeries = chart.addCandlestickSeries();
    let visibleCandles = 20; // 初始顯示50根K線
    const minCandles = 10;   // 最少顯示10根
    const maxCandles = 10000;  // 最多顯示300根
    let originalData = []; // 用來儲存K線數據
    let lastCandle = null; // 用來儲存當前的未結束K棒（例如50分的K棒）

    // 設置 WebSocket 連接
    const socket = new WebSocket('ws://localhost:8081/ws/kline'); // 替換為你的WebSocket地址

    // 監聽WebSocket消息
    socket.onmessage = function(event) {
        const message = JSON.parse(event.data);
        console.log("Got message: ", message);

        // 處理歷史K線數據 (假設歷史K線以數組形式傳送)
        if (Array.isArray(message) && message.length > 0 && message[0].type === 'historical') {
            originalData = message.map(d => ({
                time: d.time, // 假設傳來的是秒級時間戳
                open: d.open,
                high: d.high,
                low: d.low,
                close: d.close
            })).sort((a, b) => a.time - b.time);

            console.log("歷史數據：", originalData);
            candleSeries.setData(originalData); // 初始化時直接設定K線數據
            updateChart();
        }

        // 處理查詢當下的那根K棒的既有數據
        else if (message.type === 'current_kline' && message.symbol === 'BTCUSDT') {
            const currentMinute = Math.floor(message.time / 60); // 將秒級時間戳轉換為分鐘級

            // 如果沒有當前未結束的K棒，或者時間不同，創建一根新的K棒
            if (!lastCandle || Math.floor(lastCandle.time / 60) !== currentMinute) {
                if (lastCandle) {
                    // 如果有上一根K棒，則認為它已經完成，加入到數據中
                    originalData.push(lastCandle);
                    updateChart(); // 確保圖表更新
                }

                // 創建新K棒，將上一根K棒的收盤價作為新K棒的開盤價
                lastCandle = {
                    time: message.time, // 設定當前時間
                    open: lastCandle ? lastCandle.close : message.open, // 使用上一根K棒的收盤價
                    high: message.high,
                    low: message.low,
                    close: message.close
                };
            } else {
                // 如果已有當前未結束的K棒，更新其數據
                lastCandle.high = Math.max(lastCandle.high, message.high);
                lastCandle.low = Math.min(lastCandle.low, message.low);
                lastCandle.close = message.close;
            }

            // 更新圖表
            candleSeries.update(lastCandle);
        }

        // 處理實時成交數據，更新當前K棒的收盤價和最高/最低價
        else if (message.type === 'trade' && message.symbol === 'BTCUSDT') {
            const tradeMinute = Math.floor(message.time / 60); // 將trade時間轉換為分鐘級

            // 檢查 trade 是否屬於當前K線
            if (lastCandle && Math.floor(lastCandle.time / 60) === tradeMinute) {
                // 更新當前K棒的收盤價、最高價和最低價
                lastCandle.close = message.price;
                lastCandle.high = Math.max(lastCandle.high, message.price);
                lastCandle.low = Math.min(lastCandle.low, message.price);

                // 更新圖表
                candleSeries.update(lastCandle);
            } else if (lastCandle) {
                // 如果 trade 已經進入下一分鐘，將當前K棒收盤並開始新K棒
                originalData.push(lastCandle); // 將舊K棒存入數據
                updateChart(); // 更新圖表以反映舊K棒的結束

                // 創建新K棒，開盤價為上一根K棒的收盤價
                lastCandle = {
                    time: message.time,
                    open: lastCandle.close, // 使用上一根K棒的收盤價作為新K棒的開盤價
                    high: message.price,
                    low: message.price,
                    close: message.price
                };

                // 更新新K棒到圖表
                candleSeries.update(lastCandle);
            }
        }
    };


    // 錯誤處理
    socket.onerror = function(error) {
        console.error('WebSocket 出現錯誤: ', error);
    };

    // WebSocket關閉處理
    socket.onclose = function() {
        console.log('WebSocket 連接已關閉');
    };

    // 更新圖表數據
    function updateChart() {
        const dataToShow = originalData.slice(-visibleCandles);
        candleSeries.setData(dataToShow);
        // 調整時間範圍以適應數據
        chart.timeScale().fitContent();
    }


    // 監聽滑鼠滾輪事件以縮放K線數量
    document.getElementById('chart').addEventListener('wheel', function(event) {
        event.preventDefault(); // 防止頁面滾動

        if (event.deltaY < 0) {
            // 滾輪向上 (放大)
            visibleCandles = Math.max(visibleCandles - 10, minCandles);
        } else {
            // 滾輪向下 (縮小)
            visibleCandles = Math.min(visibleCandles + 10, maxCandles);
        }
        loadChart();
    });

    let isInitialLoad = true;  // 初始載入標誌
    let isLoading = false;  // 用來控制加載狀態

    // 監聽圖表的時間範圍變化來加載更多的歷史數據
    chart.timeScale().subscribeVisibleTimeRangeChange(function() {
        // 初始載入完成後才監聽用戶的操作
        if (isInitialLoad) {
            isInitialLoad = false;
            console.log('初始載入完成');
            return;
        }

        // 檢查圖表的可見範圍
        const visibleLogicalRange = chart.timeScale().getVisibleLogicalRange();
        const barsInfo = candleSeries.barsInLogicalRange(visibleLogicalRange);

        // 當顯示的數據到達圖表左邊界並且無更多數據可顯示時，才加載更多數據
        // console.log('barsInfo:', barsInfo);
        if (!isLoading && barsInfo.barsBefore<0) {
            console.log('準備加載更多數據...');
            isLoading = true;  // 標記正在加載
            loadMoreExistingData();  // 加載數據
        }
    });

    // 從已有數據中加載更多的歷史數據
    function loadMoreExistingData() {
        console.log('加載更多本地的歷史數據...');

        // 計算還能顯示的數據量，這裡每次顯示30筆
        visibleCandles = Math.min(visibleCandles + 30, originalData.length);

        // 加載本地數據到圖表中
        loadChart();

        // 檢查本地數據是否已經全部加載完畢
        if (visibleCandles >= originalData.length) {
            const earliestTimestamp = originalData[0]?.time || 0;
            console.log('最早的時間戳:', earliestTimestamp);
            console.log('本地數據已經顯示完，開始加載更多數據...');
            // 如果本地數據加載完，向後端請求更多數據
            fetch(`/api/kline/BTCUSDT/${earliestTimestamp}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(newData => {
                    console.log('接收到後端數據:', newData);

                    if (newData.length > 0) {
                        // 合併新數據與現有的 originalData
                        originalData = newData.concat(originalData);
                        console.log('合併後的 originalData:', originalData);
                        originalData.sort((a, b) => a.time - b.time);
                        visibleCandles = Math.min(visibleCandles + 30, originalData.length);
                        loadChart();  // 更新圖表
                        console.log('圖表已更新，當前 visibleCandles:', visibleCandles);
                    } else {
                        console.log('後端沒有返回新的數據');
                    }
                    isLoading = false;  // 加載完成後重置加載標誌
                })
                .catch(error => {
                    console.error("加載數據失敗", error);
                    isLoading = false;
                });
        } else {
            // 如果還有本地數據可以顯示
            setTimeout(() => {
                isLoading = false;  // 加載完成後重置加載標誌
                console.log('本地數據加載完成');
            }, 500);  // 模擬耗時
        }
    }


    // 更新圖表數據
    function loadChart() {
        const dataToShow = originalData.slice(-visibleCandles);  // 顯示最近的 visibleCandles 根K棒
        candleSeries.setData(dataToShow);
    }

    // 初始載入數據邏輯
    socket.onmessage = function(event) {
        const message = JSON.parse(event.data);

        // 處理歷史K棒數據
        if (Array.isArray(message) && message.length > 0 && message[0].type === 'historical') {
            originalData = message.map(d => ({
                time: d.time,
                open: d.open,
                high: d.high,
                low: d.low,
                close: d.close
            })).sort((a, b) => a.time - b.time);

            console.log("接收的歷史數據：", originalData);

            // 初始化圖表時僅顯示指定數量的K棒數據
            updateChart();
        }
    };

</script>
</body>
</html>
